c语言
2018/12/20
1、
typedef 声明类型的别称，方便统一更改变量的类型，增强可移植性。
2、
void 修饰返回值和形参，可作为指针类型，占4字节，是其他类型指针的祖宗，可不经强转使用。
3、
sizeof 计算变量所占内存的字节数，返回类型为unsigned int，用于计算和判断时，注意类型转换。
4、
变量间接赋值 确保指针指向地址的有效性，指针指向地址首地址，步进间隔为指针类型字节数。
5、
函数形参 传入形参是一个拷贝的临时变量。
6、
定义全局变量/函数 默认有extern，外部链接，该变量可以在其他文件访问。
定义static变量，内部链接，从定义处到文件结尾可以访问。
7、
常量区 字符串常量/全局const变量 
const全局变量（常量区）（不能直接或间接修改）
const局部变量（栈上）（可间接修改）
字符串常量 （不同编译器可能有差异，自觉遵守不可修改）
8、
代码区是共享区，只读，节约资源
9、
只要是连续内存，都能用下标进行访问 int *p = malloc(sizeof(int)*5); p[0]---p[4];
10、
NULL == P 判断一个指针是否为空，将null置左，避免误写为赋值造成意外错误。

2018/12/21
1、
宏函数（规模小） #define MYADD(x,y) ((x)+(y)) 在一定场景下效率高于函数（在预处理进行文本替换，没有函数调用过程）
2、
int arr[]={1,2,3,4 };
int *ptr=arr;
printf(＂%d,%d＂,*ptr,*(++ptr));
答案：2,2 参数压栈方向从右到左
3、
指针释放后记得置空，避免产生野指针。
4、
指针的类型不仅决定指针的步长，还决定解引用时的偏移量。
5、
offset(类型，成员)求该成员相对首地址的偏移量
struct Person
{
	int a;
	char b;
	int c;
};
struct Person p = {1,'a',89};
*(int*)((char*)&p+offset(Person,c))取出c的值。
6、
char str[] = {'h','e','l','l','o'}; //不会自动补'\0'，输出str会有乱码
char str[100] = {'h','e','l','l','o'};//未初始化部分自动补'\0'，不会乱码
字符串拷贝时注意结尾的 '\0'

2018/12/22
1、
指针指向一个连续内存的首地址，才能正确释放该块内存。
2、
const使用场景 不希望该传址变量不被改变。
3、
二级指针用于修改一级指针的指向。
4、
负数存储 源码的反码+1，符号位不变
5、
与操作 判断某一位是否为1，&0置0
6、
或操作 某一位|1置1
7、
异或操作 a^b不进位相加
交换 (a^b=r;r^b=a;r^a=b)

2018/12/24
1、
移位操 向左 *2的n次方 向右 除以2的n次幂，空出的位填充依赖于机器（有符号）
2、
数组名使用时不等价于指向首地址的指针//1、sizeof  2、对数组名取地址&  为数组指针类型，步长为数组大小
其他情况下为指向数组首元素地址的指针，数组名为一个常量指针
3、
数组下标，地址操作 p[-1] 编译后  *(p-1)
4、
定义指向数组的指针 typedef int arr_type[5];arr[5] = {}; arr_type *p = &arr;
5、
指向数组的指针取出数组值 *((*p))取出首元素值，(*p)得到首地址
6、
直接定义数组指针类型 typedef int(* arr)[5];
直接定义数组指针变量 int(* arr)[5]=&arr;

2018/12/25
1、 
二维数组数组名指向首元素地址，这时的首元素地址为一维数组类型（sizeof/取地址 除外）
2、 
int arr[][3] = {
	{1,2,3},
		{4,5,6},
			{7,8,9}
};
取第二行，第二列 	*(*(arr+1)+1);
3、 
二维数组做形参 void prin(int (*parr)[3])
4、
结构体赋值 默认逐字节赋值（浅拷贝） 若存在成员指针，应手动控制赋值操作
5、
 
2018/12/26
1、
结构体字节对齐 （类型对齐） 
2、 
函数指针 函数名字指向了函数入口的地址
3、 
函数指针定义 typedef int(FUN_type)(int,char) FUN_type* pfun = myfun;(函数名本身就是地址，无需取地址) 
typedef int(*FUN_type)(int,char) FUN_type pfun = myfun;
4、
int con1(int a, int b){逻辑1};int con2(int a, int b){逻辑2};int con3(int a, int b){逻辑3};（逻辑不同，接口一致）
int(*p)(int,int) = con1/con2/con3，函数指针做形参(回调函数)，可切换不同的逻辑
5、
函数指针数组 void(* func[3])(int a,int b);

c++语言
2018/12/27
1、
作用域 默认就近原则（全局变量和局部变量）（::作用域运算符，默认全局作用域）
2、
namespace xxxx{  } xxxx::xxx() 解决命名冲突的问题
3、
命名空间在全局下定义，可以嵌套使用，可以同名合并
4、
匿名命名空间 相当于 static xx xxx
5、 
命名空间可以起别名 namespace nam = name
6、
c++对c的增强 
全局变量的检测增强 int a;int a = 10;c能编译，c++不能
函数检测增强，参数检测，返回值检测，函数调用参数检测 
类型转换检测增强 c++中void*也得显式强转
struct增强 C语言中不能加函数，c++可以，c++可以不用struct关键字
bool类型增强 
三目运算符增强 运算返回的是变量 a<b?a:b = 100; 返回b，b=100；c(*(a<b?&a:&b) = 100)
7、
const增强 局部 const int a;c++中不可间接修改，定义时不分配内存，符号表（c语言中称为伪常量，分配内存）
8、
C语言 const默认外部链接，c++默认内部链接
9、
用普通变量初始化const变量，extern,& 会分配内存（const只要分配内存，都能用指针修改）
10、
尽量以 const 代替 #define 作用域，类型。。。
11、
引用实质-》别名，必须初始化，之后不可修改(在c++内部实现是一个指针常量 int* const p = &a)
对数组建立引用  int(&parr)[10] = arr;
12、
用一个引用带一个一级指针可以代替二级指针
13、
必须引用合法的地址空间，不要返回局部变量的引用（编译器优化的原因，第一次使用可能能访问到正常值）
局部静态变量，全局，堆上
如果函数的返回值是引用，那么这个函数可以左值 //dowork() = 10;
14、
指针的引用 int* &p 相当于二级指针，更具可读性
15、
常量引用 const int& p=10;(int tmp=10;const int &p = tmp;)又能被间接修改了

2018/12/28
1、
内联函数，弥补宏函数的缺陷，空间换时间（没有压栈出栈操作），类的成员函数，编译器默认inline，不一定真的能实现内联
2、
站位参数 int func(int a ,int);
3、
函数重载 同一作用域下，函数名相同，参数列表不同（有默认参数时，注意函数调用二义性）
const也可以作为重载的条件
函数重载原理 编译器偷偷改了函数名。。。（编译器差异性）
4、
C语言struct属性和行为分开处理，类型没有严格检测
5、
c++中struct默认权限为public，class默认权限为private，两者其他一致
6、
普通构造函数/拷贝构造函数 必须在public下（有参、无参）
拷贝构造函数 person( const person& p ){}（const &）
（如果不用&，那么每次赋值的时候调用拷贝构造函数，会无限循环调用拷贝构造）
调用默认构造函数 person p;不使用小括号调用；
person p();声明，不调用构造函数；
person（100）匿名对象，该行执行完即释放
person p = 100; <=> person p = person(100);隐式类型转换
7、
哪些时候会调用拷贝函数	
用已经创建好的对象初始化新的对象	person p = person(p1);
以值传递的方式给函数参数传值	void do(person p);p 为一份拷贝
以值的方式返回局部对象
8、
构造函数调用规则
如果用户写了构造函数，系统不再提供默认构造函数，但提供默认拷贝构造函数（简单的值拷贝）
当用户写了拷贝构造，系统不再提供其他构造
9、
系统会提供默认的拷贝构造函数，是简单的值拷贝，指针拷贝的地址（浅拷贝）-》内存泄漏，重复释放
深拷贝 拷贝指针值时，重新申请空间，存放值
10、
explicit 关键字 禁止隐式类型转换
11、
new 关键字 返回该类型指针
new 开辟数组 person* p = new person[10];调用默认构造函数，注意必须存在默认构造函数

2018/12/29
1、
static静态变量，在编译阶段分配空间，全局静态区，无论建立多少个对象都共享（类成员变量，类中声明，类外定义初始化）
2、
静态成员函数 不可以访问普通成员变量，可以访问静态成员变量
3、
类成员变量和成员函数分开存储，空类大小为1，char维护实例地址
4、
类成员表函数参数列表中，默认增加了 XXX* this ,可以解决命名冲突
5、
函数返回引用可以做左值，实现链式操作的基础
6、
空指针访问成员函数 if(this == nullptr ) return 0;
7、
常函数与常对象
void fun () const 不允许修改值（执意修改，关键字 mutable ）
const person p2;不允许修改对象属性，只能调用只读的常成员函数






























